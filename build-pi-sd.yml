# vim:ft=yaml.ansible:
---
- hosts: all
  tasks:
    - name: Create root and boot dir mount points
      file:
        path: "{{ item }}"
        state: directory
      become: true
      loop:
        - "{{ boot_dir_mnt }}"
        - "{{ root_dir_mnt }}"

    - name: Set partition facts
      set_fact:
        alarm_home_dir: "{{ root_dir_mnt }}/home/alarm/"
        root_filesystem_download_path: "{{ lookup('env', 'HOME') }}/.cache/ArchLinuxARM-rpi-3-latest.tar.gz"
        # TODO: Make this a key value pair so I can lookup the boot part by name
        desired_partitions:
          - number: 1
            raw_device: "{{ sd_device }}p1"
            logical_device: "{{ sd_device }}p1"
            name: boot
            start: 0%
            end: 300MiB
            fstype: vfat
            mount_point: "{{ boot_dir_mnt }}"
            encrypted: false
            flags:
              - lba
              - boot
          - number: 2
            raw_device: "{{ sd_device }}p2"
            logical_device: "/dev/mapper/pi-sd-root"
            name: root
            start: 300MiB
            end: 100%
            fstype: ext4
            mount_point: "{{ root_dir_mnt }}"
            encrypted: true
            flags: []
    - name: Set secondary facts
      set_fact:
        ansible_dir: "{{ alarm_home_dir }}/arch-ansible"
        gpg_keys_dir: "{{ alarm_home_dir }}/arch-ansible/secrets/gpg-keys"
        ssh_keys_dir: "{{ alarm_home_dir }}/arch-ansible/secrets/ssh-keys"

    - block:
        - name: Read SD card device info
          parted:
            device: "{{ sd_device }}"
            unit: MiB
          register: sd_device_info
          become: true
        - name: Remove extra partitions from disk
          parted:
            device: "{{ sd_device }}"
            number: "{{ item.num }}"
            state: absent
          loop: "{{ sd_device_info.partitions }}"
          when: (item.num > (desired_partitions | length)) or (wipe_card is defined and wipe_card == "true")
          become: true

        - name: Create partitions
          parted:
            device: "{{ sd_device }}"
            number: "{{ item.number }}"
            state: present
            part_type: primary
            part_start: "{{ item.start }}"
            part_end: "{{ item.end }}"
            unit: MiB
            flags: "{{ item.flags }}"
          become: true
          loop: "{{ desired_partitions }}"

        - name: LUKS format device and cryptopen it
          luks_device:
            device: "{{ item.raw_device }}"
            state: "opened"
            name: "{{ item.logical_device | basename }}"
            keyfile: secrets/luks-keyfile
          become: true
          loop: "{{ desired_partitions }}"
          when: item.encrypted
          register: luks_format_result

        # TODO: Make this idempotent
        - name: Create partition filesystems
          filesystem:
            fstype: "{{ item.fstype }}"
            dev: "{{ item.logical_device }}"
            force: true
          become: true
          loop: "{{ desired_partitions }}"

        - name: Mount partition filesystem
          mount:
            fstype: "{{ item.fstype }}"
            src: "{{ item.logical_device }}"
            path: "{{ item.mount_point }}"
            state: mounted
          become: true
          loop: "{{ desired_partitions }}"

        - name: Check for root filesystem download
          stat:
            path: "{{ root_filesystem_download_path }}"
          register: root_filesystem_download_check_result

        - name: Download root filesystem
          get_url:
            url: http://os.archlinuxarm.org/os/ArchLinuxARM-rpi-3-latest.tar.gz
            dest: "{{ root_filesystem_download_path }}"
          when: not root_filesystem_download_check_result.stat.exists

        # # TODO: Make this idempotent
        - name: Extract root filesystem
          unarchive:
            src: "{{ root_filesystem_download_path }}"
            dest: "{{ root_dir_mnt }}"
          become: true

        # TODO: Make this idempotent
        - name: Move boot files to boot partition
          shell: "mv {{ root_dir_mnt }}/boot/* {{ boot_dir_mnt }}/"
          become: true

        - name: Unmount boot dir
          mount:
            path: "{{ boot_dir_mnt }}"
            state: unmounted
          become: true

        - name: Mount boot dir under root dir
          mount:
            path: "{{ root_dir_mnt }}/boot"
            src: "{{ sd_device }}p1"
            state: mounted
            fstype: vfat
          become: true

        - name: Copy arch-ansible to root
          become: true
          synchronize:
            src: "{{ playbook_dir }}/"
            dest: "{{ ansible_dir }}"

        - name: Add tmux config to root
          become: true
          copy:
            src: files/tmux.conf
            dest: "{{ alarm_home_dir }}/.tmux.conf"

        - name: Create gpg-keys dir
          become: true
          file:
            path: "{{ gpg_keys_dir }}"
            state: directory

        # TODO: Make this idempotent
        - name: export gpg private key
          command: gpg --armor --export-secret-key '{{ pass_gpg_key }}'
          args:
            creates: "{{ gpg_keys_dir }}/private-key.asc"
          register: gpg_private_export_cmd
          no_log: true
        - name: write gpg private key
          copy:
            dest: "{{ gpg_keys_dir }}/private-key.asc"
            content: "{{ gpg_private_export_cmd.stdout }}"
          become: true
          no_log: true
          when: gpg_private_export_cmd.changed

        - name: export gpg public key
          command: gpg --armor --export '{{ pass_gpg_key }}'
          no_log: true
          register: gpg_public_export_cmd
          args:
            creates: "{{ gpg_keys_dir }}/public-key.asc"
        - name: write gpg public key
          become: true
          no_log: true
          when: gpg_public_export_cmd.changed
          copy:
            dest: "{{ gpg_keys_dir }}/public-key.asc"
            content: "{{ gpg_public_export_cmd.stdout }}"

        - name: create ssh-keys dir
          become: true
          file:
            path: "{{ ssh_keys_dir }}"
            state: directory
        - name: copy ssh private key
          become: true
          copy:
            src: "{{ lookup('env', 'HOME') }}/.ssh/id_rsa"
            dest: "{{ ssh_keys_dir }}/id_rsa"
            owner: root
        - name: copy ssh public key
          become: true
          copy:
            src: "{{ lookup('env', 'HOME') }}/.ssh/id_rsa.pub"
            dest: "{{ ssh_keys_dir }}/id_rsa.pub"

        - name: install resolvconf.conf
          become: true
          copy:
            src: files/resolvconf.conf
            dest: "{{ root_dir_mnt }}/etc/resolvconf.conf"

        - name: create systemd-nspawn service file directory
          become: true
          file:
            path: /etc/systemd/nspawn
            state: directory

        - name: Install nspawn config for arch-pi
          become: true
          copy:
            src: files/arch-pi.nspawn
            dest: "/etc/systemd/nspawn/arch-pi.nspawn"

        - name: Ensure root dir permissions
          become: true
          file:
            path: "{{ root_dir_mnt }}"
            owner: root
            group: root

        - name: Start arch-pi container
          become: true
          systemd:
            state: started
            name: systemd-nspawn@arch-pi.service
            daemon-reload: true
        # Right now pi dies at "unknown filesystem type 'crypto_LUKS'"
        # Replace below with machinectl connection plugin
        # Maybe allow alarm user to log in without pw?
        # - name: Init pacman keys in nspawn container
        #   become: true
        #   command: "systemd-nspawn --bind /usr/bin/qemu-arm-static -b -D {{ root_dir_mnt }} pacman-key --init"
        #
        # - name: Populate ARM pacman keys in nspawn container
        #   become: true
        #   command: "systemd-nspawn --bind /usr/bin/qemu-arm-static -b -D {{ root_dir_mnt }} pacman-key --populate archlinuxarm"
        #
        # - name: Update and install pacakges in nspawn container
        #   become: true
        #   command: "systemd-nspawn --bind /usr/bin/qemu-arm-static -b -D {{ root_dir_mnt }} pacman -Suy lvm2 cryptsetup sudo git rsync base base-devel uboot-tools dropbear mkinitcpio-utils mkinitcpio-netconf mkinitcpio-dropbear"
        #
        # - name: Set hostname nspawn container
        #   become: true
        #   command: "systemd-nspawn --bind /usr/bin/qemu-arm-static -b -D {{ root_dir_mnt }} hostnamectl set-hostname panamint"
        #
        # - name: Add alarm user to sudoers
        #   become: true
        #   lineinfile:
        #     dest: "{{ root_dir_mnt }}/etc/sudoers"
        #     line: "alarm ALL=(ALL)"
        #     state: present
        #     create: yes
      always:
        - name: Unmount temp boot dir
          mount:
            path: "{{ arch_pi_boot_temp_dir.path }}"
            state: unmounted
          when: arch_pi_boot_temp_dir is defined and arch_pi_boot_temp_dir.skipped is not defined
          become: true

        - name: Remove temp boot dir mount point
          when: arch_pi_boot_temp_dir is defined and arch_pi_boot_temp_dir.skipped is not defined
          file:
            path: "{{ arch_pi_boot_temp_dir.path }}"
            state: absent

        - name: Unmount temp root dir
          mount:
            path: "{{ arch_pi_root_temp_dir.path }}"
            state: unmounted
          when: arch_pi_root_temp_dir is defined and arch_pi_root_temp_dir.skipped is not defined
          become: true

        - name: Remove temp root dir mount point
          when: arch_pi_root_temp_dir is defined and arch_pi_root_temp_dir.skipped is not defined
          file:
            path: "{{ arch_pi_root_temp_dir.path }}"
            state: absent

        - name: Close LUKS devices
          luks_device:
            device: "{{ item.raw_device }}"
            state: "closed"
            name: "{{ item.logical_device | basename }}"
          become: true
          loop: "{{ desired_partitions }}"
          when: luks_format_result is succeeded and item.encrypted
