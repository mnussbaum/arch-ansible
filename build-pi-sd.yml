# vim:ft=yaml.ansible:
---
- hosts: all
  tasks:
    - name: Create temp boot dir mount point
      tempfile:
        state: directory
        suffix: arch-pi-boot
      register: arch_pi_boot_temp_dir
      when: boot_dir_mnt is not defined

    - name: Set boot_dir_mnt
      set_fact:
        boot_dir_mnt: "{{ arch_pi_boot_temp_dir.path }}"
      when: boot_dir_mnt is not defined

    - name: Create temp root dir mount point
      tempfile:
        state: directory
        suffix: arch-pi-root
      register: arch_pi_root_temp_dir
      when: root_dir_mnt is not defined

    - name: Set root_dir_mnt
      set_fact:
        root_dir_mnt: "{{ arch_pi_root_temp_dir.path }}"
      when: root_dir_mnt is not defined

    - name: Set partition facts
      set_fact:
        desired_partitions:
          - number: 1
            raw_device: "{{ sd_device }}p1"
            logical_device: "{{ sd_device }}p1"
            name: boot
            start: 0%
            end: 300MiB
            fstype: vfat
            mount_point: "{{ boot_dir_mnt }}"
            encrypted: false
          - number: 2
            raw_device: "{{ sd_device }}p2"
            logical_device: "{{ sd_device }}p2"
            name: installation
            start: 300MiB
            end: 3372MiB
            fstype: ext4
            mount_point: "{{ root_dir_mnt }}"
            encrypted: false
          - number: 3
            raw_device: "{{ sd_device }}p3"
            logical_device: "/dev/mapper/pi-sd-root"
            name: root
            start: 3372MiB
            end: 100%
            fstype: ext4
            mount_point: "{{ root_dir_mnt }}"
            encrypted: true

    - block:
        - name: Read SD card device info
          parted:
            device: "{{ sd_device }}"
            unit: MiB
          register: sd_device_info
          become: true
        - name: Remove extra partitions from disk
          parted:
            device: "{{ sd_device }}"
            number: "{{ item.num }}"
            state: absent
          loop: "{{ sd_device_info.partitions }}"
          when: (item.num > (desired_partitions | length)) or (wipe_card is defined and wipe_card == "true")
          become: true

        - name: Create partitions
          parted:
            device: "{{ sd_device }}"
            number: "{{ item.number }}"
            state: present
            part_type: primary
            part_start: "{{ item.start }}"
            part_end: "{{ item.end }}"
            unit: MiB
          become: true
          loop: "{{ desired_partitions }}"

        - name: LUKS format device and cryptopen it
          luks_device:
            device: "{{ item.raw_device }}"
            state: "opened"
            name: "{{ item.logical_device | basename }}"
            keyfile: "luks-keyfile"
          become: true
          loop: "{{ desired_partitions }}"
          when: item.encrypted
          register: luks_format_result

        - name: Create partition filesystems
          filesystem:
            fstype: "{{ item.fstype }}"
            dev: "{{ item.logical_device }}"
          become: true
          loop: "{{ desired_partitions }}"

        - name: Mount partition filesystem
          mount:
            fstype: "{{ item.fstype }}"
            src: "{{ item.logical_device }}"
            path: "{{ item.mount_point }}"
            state: mounted
          become: true
          loop: "{{ desired_partitions }}"

        - name: Check if root filesystem downloaded
          find:
            paths: "{{ root_dir_mnt }}"
            file_type: directory
            patterns: ".*"
            excludes: '^lost\+found'
            use_regex: true
          register: root_filesystem_files

        - name: Download and extract root filesystem
          unarchive:
            src: http://archlinuxarm.org/os/ArchLinuxARM-rpi-3-latest.tar.gz
            remote_src: true
            dest: "{{ root_dir_mnt }}"
          become: true
          when: root_filesystem_files.matched | int == 0

        - name: Copy boot files to boot partition
          copy:
            src: "{{ root_dir_mnt }}/boot/"
            dest: "{{ boot_dir_mnt }}"
          become: true

        - name: Set ansible and key dirs
          set_fact:
            alarm_home_dir: "{{ root_dir_mnt }}/home/alarm"

        - name: Set ansible and key dirs
          set_fact:
            ansible_dir: "{{ alarm_home_dir }}/arch-ansible"
            gpg_keys_dir: "{{ alarm_home_dir }}/arch-ansible/gpg-keys"
            ssh_keys_dir: "{{ alarm_home_dir }}/arch-ansible/ssh-keys"

        - name: Copy arch-ansible to root
          become: true
          synchronize:
            src: "{{ playbook_dir }}/"
            dest: "{{ ansible_dir }}"

        - name: Add tmux config to root
          become: true
          copy:
            src: files/tmux.conf
            dest: "{{ alarm_home_dir }}/.tmux.conf"

        - name: Create gpg-keys dir
          become: true
          file:
            path: "{{ gpg_keys_dir }}"
            state: directory

        - name: Export gpg private key
          command: gpg --armor --export-secret-key '{{ pass_gpg_key }}'
          args:
            creates: "{{ gpg_keys_dir }}/private-key.asc"
          register: gpg_private_export_cmd
          no_log: true
        - name: Write gpg private key
          copy:
            dest: "{{ gpg_keys_dir }}/private-key.asc"
            content: "{{ gpg_private_export_cmd.stdout }}"
          become: true
          no_log: true
          when: gpg_private_export_cmd.changed

        - name: Export gpg public key
          command: gpg --armor --export '{{ pass_gpg_key }}'
          no_log: true
          register: gpg_public_export_cmd
          args:
            creates: "{{ gpg_keys_dir }}/public-key.asc"
        - name: Write gpg public key
          become: true
          no_log: true
          when: gpg_public_export_cmd.changed
          copy:
            dest: "{{ gpg_keys_dir }}/public-key.asc"
            content: "{{ gpg_public_export_cmd.stdout }}"

        - name: Create ssh-keys dir
          become: true
          file:
            path: "{{ ssh_keys_dir }}"
            state: directory
        - name: Copy SSH private key
          become: true
          copy:
            src: "{{ lookup('env', 'HOME') }}/.ssh/id_rsa"
            dest: "{{ ssh_keys_dir }}/id_rsa"
            owner: root
        - name: Copy SSH public key
          become: true
          copy:
            src: "{{ lookup('env', 'HOME') }}/.ssh/id_rsa.pub"
            dest: "{{ ssh_keys_dir }}/id_rsa.pub"

      always:
        - name: Unmount temp boot dir
          mount:
            path: "{{ arch_pi_boot_temp_dir.path }}"
            state: unmounted
          when: arch_pi_boot_temp_dir is defined and arch_pi_boot_temp_dir.skipped is not defined
          become: true

        - name: Remove temp boot dir mount point
          when: arch_pi_boot_temp_dir is defined and arch_pi_boot_temp_dir.skipped is not defined
          file:
            path: "{{ arch_pi_boot_temp_dir.path }}"
            state: absent

        - name: Unmount temp root dir
          mount:
            path: "{{ arch_pi_root_temp_dir.path }}"
            state: unmounted
          when: arch_pi_root_temp_dir is defined and arch_pi_root_temp_dir.skipped is not defined
          become: true

        - name: Remove temp root dir mount point
          when: arch_pi_root_temp_dir is defined and arch_pi_root_temp_dir.skipped is not defined
          file:
            path: "{{ arch_pi_root_temp_dir.path }}"
            state: absent

        - name: Close LUKS devices
          luks_device:
            device: "{{ item.raw_device }}"
            state: "closed"
            name: "{{ item.logical_device | basename }}"
          become: true
          loop: "{{ desired_partitions }}"
          when: luks_format_result is succeeded and item.encrypted
    # Next comes the booted or maybe QEMU setup
